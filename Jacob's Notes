Jacob's Notes:

1. For solve_supply/solve_demand    file: markets/problem_market.py
2. solve_supply relies on function safely_compute_tilde_costs which is also defined in problem_market.py
3. safely_compute_tilde_costs relies on function compute_eta    file: markets/market.py
4. compute_eta is where the key supply solving takes place. Key bit of code:
        
        utility_derivatives = self.compute_utility_derivatives('prices')
        probabilities, conditionals = self.compute_probabilities(delta)
        jacobian = self.compute_shares_by_variable_jacobian(utility_derivatives, probabilities, conditionals)
        capital_delta = -ownership_matrix * jacobian
        # approximately_solve(a,b) = a^(-1) * b
        eta, replacement = approximately_solve(capital_delta, self.products.shares)

    Note: that there is also a compute_eta_by_theta_jacobian function also in markets.py.
        Not sure where this comes in to play


If we want to allow double marginalization we need to calculate the extra capital_delta term from Gayle paper. 